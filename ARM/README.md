# ARM
ARM主要负责示波器的交互显示，程序通过交叉编译工具编译后在linux系统运行。在程序运行时，主线程会创建3个线程，分别完成显示、按键处理和触屏处理。分线程显示线程是最重要的程序，在显示程序被创建后，该线程会先初始化字体库、FPGA、ADC、DAC、CD4096和OpenCL。本次比赛主要完成了：
- [交互显示](#交互显示)
    - [键盘处理](#键盘处理)
    - [触屏处理](#触屏处理)
    - [UI显示](#UI显示)
- [抽值](#抽值)
- [插值](#插值)
- [自动设置](#自动设置)
- [OpenCL部署神经网络](#OpenCL部署神经网络)

## 交互显示
### 键盘处理
键值通过linux的UART通信，使用串口地址为`/dev/ttyS0`波特率为`19200`数据位为8位，停止位为1位，无校验。工作时由按键线程循环读取串口数据后进行处理。处理键值设计为分部分处理提高处理效率，即将8位键值分段，细分后通过switch语句完成处理。

### 触屏处理
触屏值由字符设备文件获取，地址为`/dev/input/event1`。触屏返回值包括事件类型、事件代码和事件的值。触屏动作分为开始触碰，触碰持续和触屏结束。本次比赛中只完成了对点触类型的触屏操作处理。

### UI显示
显示由DRM（Direct Rendering Manager）完成，地址为`/dev/dri/card0`，屏幕分辨率为`480*800`。在操作显示时，显示数据数组储存每一个像素点的RGB值以完成显示。而在显示处理时会根据当前状态对该数组进行反复的覆写，这会占用大量的资源，本次比赛中，设计将整个显示区域分块，并对不同区域分帧处理，按区域重要性和实时性设定不同的刷新间隔帧数。

## 抽值
等距抽点完成抽值操作，软件实现方式为循环遍历原数组间隔赋值到另一个数组。但当硬件单次传输数据确定后，抽值将导致显示数据量减少。

## 插值
在ARM端实现过线性插值和SinC插值两种插值方法。线性插值对于正弦类波形的插值效果随着信号源的频率增大而变差（一个周期内的采样点数降低）。而SinC插值受噪声会产生畸变波形，且单纯使用ARM的软件资源计算会造成极大的资源浪费，降低屏幕刷新帧数。

## 自动设置
自动设置需完成多项功能的自动设置。此次比赛只完成了对波形显示的矫正。矫正过程为先根据FPGA测得频率设置时基档位大于合适档位，以减少FPGA抽值后须大量采集样本点造成的时间损耗。然后根据中值调整后级偏置，调整过程中根据当前中值距离目标中值所在的距离分段，设置相应的调整倍率后进行调整（距离目标值越远调整值越大）。偏置调整后，根据峰峰值调整幅格档位，由于不同幅格档位的偏置条件不同，此时又须返回重新调整偏置。待偏置幅格都调整完毕后，时基再查表调整。  
以上逻辑设计的方法存在很多bug。
- FGPA测频结果还未返回就打开自动设置将严重影响自动设置效果。
- 未对整个波形偏离出ADC的采样范围进行考虑（采的数据只存在0或255两种情况）。  

应完善基线校准功能，并处理分开外部偏移情况和内部调整造成的偏移情况。

## OpenCL部署神经网络
通过OpenCL部署的好处是，部署迁移周期非常短，在不同平台都可以利用OpenCL部署，移植到示波器上只需修改少量参数，但须考虑场景需求。  
本次赛事部署网络在DSP上虽实现了异常检测的功能，但由于示波器的死区，在理论上并不能解决偶发异常的捕获。
